
timer-music-test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000049a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000194  00802000  0000049a  0000052e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000030  00802194  00802194  000006c2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000006c2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000006f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000068  00000000  00000000  00000734  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002d55  00000000  00000000  0000079c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c9d  00000000  00000000  000034f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005f5  00000000  00000000  0000518e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000014c  00000000  00000000  00005784  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cf5  00000000  00000000  000058d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000003e1  00000000  00000000  000075c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000058  00000000  00000000  000079a6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  30:	0c 94 99 01 	jmp	0x332	; 0x332 <__vector_12>
  34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  44:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	cd bf       	out	0x3d, r28	; 61
  b4:	d7 e2       	ldi	r29, 0x27	; 39
  b6:	de bf       	out	0x3e, r29	; 62

000000b8 <__do_copy_data>:
  b8:	11 e2       	ldi	r17, 0x21	; 33
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b0 e2       	ldi	r27, 0x20	; 32
  be:	ea e9       	ldi	r30, 0x9A	; 154
  c0:	f4 e0       	ldi	r31, 0x04	; 4
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	a4 39       	cpi	r26, 0x94	; 148
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	21 e2       	ldi	r18, 0x21	; 33
  d0:	a4 e9       	ldi	r26, 0x94	; 148
  d2:	b1 e2       	ldi	r27, 0x21	; 33
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a4 3c       	cpi	r26, 0xC4	; 196
  da:	b2 07       	cpc	r27, r18
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	0e 94 52 01 	call	0x2a4	; 0x2a4 <main>
  e2:	0c 94 4b 02 	jmp	0x496	; 0x496 <_exit>

000000e6 <__bad_interrupt>:
  e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <clk_init>:
uint8_t isIntroTreble = 1;
uint8_t isIntroBass = 1;

void clk_init()
{
	CCP = CCP_IOREG_gc;
  ea:	88 ed       	ldi	r24, 0xD8	; 216
  ec:	84 bf       	out	0x34, r24	; 52
	OSC_CTRL = OSC_RC32MEN_bm;
  ee:	82 e0       	ldi	r24, 0x02	; 2
  f0:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7fb050>
	
	while(!(OSC_STATUS & OSC_RC32MRDY_bm)){};
  f4:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7fb051>
  f8:	81 ff       	sbrs	r24, 1
  fa:	fc cf       	rjmp	.-8      	; 0xf4 <clk_init+0xa>
	
	CCP = CCP_IOREG_gc;
  fc:	88 ed       	ldi	r24, 0xD8	; 216
  fe:	84 bf       	out	0x34, r24	; 52
	CLK_CTRL = CLK_SCLKSEL_RC32M_gc;
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7fb040>
 106:	08 95       	ret

00000108 <interrupts_init>:
	
}

void interrupts_init()
{
	PMIC_CTRL = PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm;
 108:	87 e0       	ldi	r24, 0x07	; 7
 10a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7fb0a2>
 10e:	08 95       	ret

00000110 <timer_C4_init>:


void timer_C4_init()
{
	//for 136 BMP and 1/16 note support, 64 prescl and 13787 clk
	TCC4.CTRLB = TC_BYTEM_NORMAL_gc | TC_CIRCEN_DISABLE_gc | TC_WGMODE_NORMAL_gc;
 110:	e0 e0       	ldi	r30, 0x00	; 0
 112:	f8 e0       	ldi	r31, 0x08	; 8
 114:	11 82       	std	Z+1, r1	; 0x01
	TCC4.CTRLE = 0;
 116:	14 82       	std	Z+4, r1	; 0x04
	TCC4.INTCTRLA = TC_OVFINTLVL_HI_gc;
 118:	83 e0       	ldi	r24, 0x03	; 3
 11a:	86 83       	std	Z+6, r24	; 0x06
	TCC4.CTRLA = 0;	
 11c:	10 82       	st	Z, r1
	TCC4.PER = 13787 ;
 11e:	8b ed       	ldi	r24, 0xDB	; 219
 120:	95 e3       	ldi	r25, 0x35	; 53
 122:	86 a3       	std	Z+38, r24	; 0x26
 124:	97 a3       	std	Z+39, r25	; 0x27
 126:	08 95       	ret

00000128 <timer_C5_init>:
}

//Treble Counter
void timer_C5_init()
{
	PORTC.DIRSET = PIN4_bm;
 128:	80 e1       	ldi	r24, 0x10	; 16
 12a:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x7fb641>
	//PORTC.REMAP = PORT_TC4A_bm;

	TCC5.CTRLB = TC_BYTEM_NORMAL_gc | TC_CIRCEN_DISABLE_gc | TC_WGMODE_FRQ_gc;
 12e:	e0 e4       	ldi	r30, 0x40	; 64
 130:	f8 e0       	ldi	r31, 0x08	; 8
 132:	81 e0       	ldi	r24, 0x01	; 1
 134:	81 83       	std	Z+1, r24	; 0x01
	TCC5.CTRLE = TC_CCAMODE_COMP_gc | TC_CCBMODE_COMP_gc;
 136:	85 e0       	ldi	r24, 0x05	; 5
 138:	84 83       	std	Z+4, r24	; 0x04
	TCC5.CTRLA = TC_CLKSEL_DIV8_gc;
 13a:	84 e0       	ldi	r24, 0x04	; 4
 13c:	80 83       	st	Z, r24
 13e:	08 95       	ret

00000140 <timer_D5_init>:
}

//Base Counter
void timer_D5_init()
{
	PORTD.DIRSET = PIN4_bm;
 140:	80 e1       	ldi	r24, 0x10	; 16
 142:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x7fb661>
	//PORTC.REMAP = PORT_TC4A_bm;
	
	TCD5.CTRLB = TC_BYTEM_NORMAL_gc | TC_CIRCEN_DISABLE_gc | TC_WGMODE_FRQ_gc;
 146:	e0 e4       	ldi	r30, 0x40	; 64
 148:	f9 e0       	ldi	r31, 0x09	; 9
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	81 83       	std	Z+1, r24	; 0x01
	TCD5.CTRLE = TC_CCAMODE_COMP_gc | TC_CCBMODE_COMP_gc;
 14e:	85 e0       	ldi	r24, 0x05	; 5
 150:	84 83       	std	Z+4, r24	; 0x04
	TCD5.CTRLA = TC_CLKSEL_DIV8_gc;
 152:	84 e0       	ldi	r24, 0x04	; 4
 154:	80 83       	st	Z, r24
 156:	08 95       	ret

00000158 <setNoteAndBeat>:
}

//Returns the clock count of the note, sets the beat counter for the note, and updates the indexes
uint16_t setNoteAndBeat(uint8_t * noteBeatCountPtr, uint8_t * notesPtr, uint8_t * noteExtPtr, uint16_t * noteIndexPtr, uint16_t * noteExtIndexPtr, uint8_t * extBitPosPtr)
{
 158:	cf 92       	push	r12
 15a:	df 92       	push	r13
 15c:	ef 92       	push	r14
 15e:	ff 92       	push	r15
 160:	0f 93       	push	r16
 162:	1f 93       	push	r17
 164:	cf 93       	push	r28
 166:	df 93       	push	r29
 168:	6c 01       	movw	r12, r24
 16a:	e9 01       	movw	r28, r18
 16c:	d7 01       	movw	r26, r14
	*noteBeatCountPtr = 0x01;
 16e:	81 e0       	ldi	r24, 0x01	; 1
 170:	f6 01       	movw	r30, r12
 172:	80 83       	st	Z, r24
	uint8_t noteVal = notesPtr[*noteIndexPtr];
 174:	88 81       	ld	r24, Y
 176:	99 81       	ldd	r25, Y+1	; 0x01
 178:	68 0f       	add	r22, r24
 17a:	79 1f       	adc	r23, r25
 17c:	fb 01       	movw	r30, r22
 17e:	90 81       	ld	r25, Z
	uint8_t beats = *noteBeatCountPtr;
	beats <<= (noteVal >> 6);
 180:	89 2f       	mov	r24, r25
 182:	82 95       	swap	r24
 184:	86 95       	lsr	r24
 186:	86 95       	lsr	r24
 188:	83 70       	andi	r24, 0x03	; 3
 18a:	61 e0       	ldi	r22, 0x01	; 1
 18c:	70 e0       	ldi	r23, 0x00	; 0
 18e:	02 c0       	rjmp	.+4      	; 0x194 <setNoteAndBeat+0x3c>
 190:	66 0f       	add	r22, r22
 192:	77 1f       	adc	r23, r23
 194:	8a 95       	dec	r24
 196:	e2 f7       	brpl	.-8      	; 0x190 <setNoteAndBeat+0x38>
	beats -= 1; //This will turn 0b0010 into 0b0001 or 0b0100 into 0b0011. A cheap way of doing a power of 2
 198:	61 50       	subi	r22, 0x01	; 1
	
	//0b00000001 << 3 = 0b00001000. 0b00001000 - 1 = 0b00000111
	//when we count down the number of 1/16 beats the note will be played for it will always play 1 1/16,
	//then decrement the beat counter until it reaches 0. So, a beat of 7 will play 8 beats, or a half note
	uint8_t extByte = noteExtPtr[*noteExtIndexPtr];
 19a:	f8 01       	movw	r30, r16
 19c:	20 81       	ld	r18, Z
 19e:	31 81       	ldd	r19, Z+1	; 0x01
 1a0:	42 0f       	add	r20, r18
 1a2:	53 1f       	adc	r21, r19
 1a4:	fa 01       	movw	r30, r20
 1a6:	20 81       	ld	r18, Z
	if ((extByte >> (*extBitPosPtr)) & 0x01) //if the extension bit is set then this is a whole note
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	0c 90       	ld	r0, X
 1ac:	02 c0       	rjmp	.+4      	; 0x1b2 <setNoteAndBeat+0x5a>
 1ae:	35 95       	asr	r19
 1b0:	27 95       	ror	r18
 1b2:	0a 94       	dec	r0
 1b4:	e2 f7       	brpl	.-8      	; 0x1ae <setNoteAndBeat+0x56>
 1b6:	20 fd       	sbrc	r18, 0
	{
		beats = 0x0F;
 1b8:	6f e0       	ldi	r22, 0x0F	; 15
	}
	*noteBeatCountPtr = beats;
 1ba:	f6 01       	movw	r30, r12
 1bc:	60 83       	st	Z, r22
	//Get the counts from the note as an index
	uint16_t index = noteVal & 0x3F;
 1be:	9f 73       	andi	r25, 0x3F	; 63
 1c0:	89 2f       	mov	r24, r25
 1c2:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t count = 0;
	if (index > 0)
 1c4:	00 97       	sbiw	r24, 0x00	; 0
 1c6:	51 f0       	breq	.+20     	; 0x1dc <setNoteAndBeat+0x84>
	{
		count = noteClocks[index] / 2;
 1c8:	88 0f       	add	r24, r24
 1ca:	99 1f       	adc	r25, r25
 1cc:	fc 01       	movw	r30, r24
 1ce:	ed 5e       	subi	r30, 0xED	; 237
 1d0:	fe 4d       	sbci	r31, 0xDE	; 222
 1d2:	40 81       	ld	r20, Z
 1d4:	51 81       	ldd	r21, Z+1	; 0x01
 1d6:	56 95       	lsr	r21
 1d8:	47 95       	ror	r20
 1da:	02 c0       	rjmp	.+4      	; 0x1e0 <setNoteAndBeat+0x88>
		beats = 0x0F;
	}
	*noteBeatCountPtr = beats;
	//Get the counts from the note as an index
	uint16_t index = noteVal & 0x3F;
	uint16_t count = 0;
 1dc:	40 e0       	ldi	r20, 0x00	; 0
 1de:	50 e0       	ldi	r21, 0x00	; 0
		count = noteClocks[index] / 2;
	}
	
	
	//Increment the note index and the bit pos of the ext
	(*noteIndexPtr)++;
 1e0:	28 81       	ld	r18, Y
 1e2:	39 81       	ldd	r19, Y+1	; 0x01
 1e4:	2f 5f       	subi	r18, 0xFF	; 255
 1e6:	3f 4f       	sbci	r19, 0xFF	; 255
 1e8:	28 83       	st	Y, r18
 1ea:	39 83       	std	Y+1, r19	; 0x01
	(*extBitPosPtr)++;
 1ec:	9c 91       	ld	r25, X
 1ee:	9f 5f       	subi	r25, 0xFF	; 255
 1f0:	9c 93       	st	X, r25
	
	//If we have maxed out the bit pos, move to the next ext byte
	if (*extBitPosPtr == 8)
 1f2:	98 30       	cpi	r25, 0x08	; 8
 1f4:	39 f4       	brne	.+14     	; 0x204 <__EEPROM_REGION_LENGTH__+0x4>
	{
		*extBitPosPtr = 0;
 1f6:	1c 92       	st	X, r1
		(*noteExtIndexPtr)++;
 1f8:	f8 01       	movw	r30, r16
 1fa:	80 81       	ld	r24, Z
 1fc:	91 81       	ldd	r25, Z+1	; 0x01
 1fe:	01 96       	adiw	r24, 0x01	; 1
 200:	80 83       	st	Z, r24
 202:	91 83       	std	Z+1, r25	; 0x01
	}
	
	return count;
	
}
 204:	ca 01       	movw	r24, r20
 206:	df 91       	pop	r29
 208:	cf 91       	pop	r28
 20a:	1f 91       	pop	r17
 20c:	0f 91       	pop	r16
 20e:	ff 90       	pop	r15
 210:	ef 90       	pop	r14
 212:	df 90       	pop	r13
 214:	cf 90       	pop	r12
 216:	08 95       	ret

00000218 <setNoteAndBeatTreble>:


//Uses the current note indexes for treble
void setNoteAndBeatTreble() 
{
 218:	ef 92       	push	r14
 21a:	ff 92       	push	r15
 21c:	0f 93       	push	r16
 21e:	1f 93       	push	r17
	//The note number is the first 6 bits of the byte for that note and represents the index into the note clocks
	TCC5.CCA = setNoteAndBeat(&noteBeatCountTreble, notesTreblePtr, notesExtTreblePtr, &noteIndexTreble, &noteExtIndexTreble, &noteExtBitPosTreble);	 
 220:	40 91 1a 20 	lds	r20, 0x201A	; 0x80201a <notesExtTreblePtr>
 224:	50 91 1b 20 	lds	r21, 0x201B	; 0x80201b <notesExtTreblePtr+0x1>
 228:	60 91 1c 20 	lds	r22, 0x201C	; 0x80201c <notesTreblePtr>
 22c:	70 91 1d 20 	lds	r23, 0x201D	; 0x80201d <notesTreblePtr+0x1>
 230:	0f 2e       	mov	r0, r31
 232:	f0 ea       	ldi	r31, 0xA0	; 160
 234:	ef 2e       	mov	r14, r31
 236:	f1 e2       	ldi	r31, 0x21	; 33
 238:	ff 2e       	mov	r15, r31
 23a:	f0 2d       	mov	r31, r0
 23c:	01 ea       	ldi	r16, 0xA1	; 161
 23e:	11 e2       	ldi	r17, 0x21	; 33
 240:	23 ea       	ldi	r18, 0xA3	; 163
 242:	31 e2       	ldi	r19, 0x21	; 33
 244:	8f e9       	ldi	r24, 0x9F	; 159
 246:	91 e2       	ldi	r25, 0x21	; 33
 248:	0e 94 ac 00 	call	0x158	; 0x158 <setNoteAndBeat>
 24c:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x7fb868>
 250:	90 93 69 08 	sts	0x0869, r25	; 0x800869 <__TEXT_REGION_LENGTH__+0x7fb869>
}
 254:	1f 91       	pop	r17
 256:	0f 91       	pop	r16
 258:	ff 90       	pop	r15
 25a:	ef 90       	pop	r14
 25c:	08 95       	ret

0000025e <setNoteAndBeatBass>:

//Uses the current note indexes for Bass
void setNoteAndBeatBass()
{
 25e:	ef 92       	push	r14
 260:	ff 92       	push	r15
 262:	0f 93       	push	r16
 264:	1f 93       	push	r17
	//The note number is the first 6 bits of the byte for that note and represents the index into the note clocks
	TCD5.CCA = setNoteAndBeat(&noteBeatCountBass, notesBassPtr, notesExtBassPtr, &noteIndexBass, &noteExtIndexBass, &noteExtBitPosBass);
 266:	40 91 02 20 	lds	r20, 0x2002	; 0x802002 <notesExtBassPtr>
 26a:	50 91 03 20 	lds	r21, 0x2003	; 0x802003 <notesExtBassPtr+0x1>
 26e:	60 91 04 20 	lds	r22, 0x2004	; 0x802004 <notesBassPtr>
 272:	70 91 05 20 	lds	r23, 0x2005	; 0x802005 <notesBassPtr+0x1>
 276:	0f 2e       	mov	r0, r31
 278:	f5 e9       	ldi	r31, 0x95	; 149
 27a:	ef 2e       	mov	r14, r31
 27c:	f1 e2       	ldi	r31, 0x21	; 33
 27e:	ff 2e       	mov	r15, r31
 280:	f0 2d       	mov	r31, r0
 282:	06 e9       	ldi	r16, 0x96	; 150
 284:	11 e2       	ldi	r17, 0x21	; 33
 286:	28 e9       	ldi	r18, 0x98	; 152
 288:	31 e2       	ldi	r19, 0x21	; 33
 28a:	84 e9       	ldi	r24, 0x94	; 148
 28c:	91 e2       	ldi	r25, 0x21	; 33
 28e:	0e 94 ac 00 	call	0x158	; 0x158 <setNoteAndBeat>
 292:	80 93 68 09 	sts	0x0968, r24	; 0x800968 <__TEXT_REGION_LENGTH__+0x7fb968>
 296:	90 93 69 09 	sts	0x0969, r25	; 0x800969 <__TEXT_REGION_LENGTH__+0x7fb969>
}
 29a:	1f 91       	pop	r17
 29c:	0f 91       	pop	r16
 29e:	ff 90       	pop	r15
 2a0:	ef 90       	pop	r14
 2a2:	08 95       	ret

000002a4 <main>:

int main(void)
{
    /* Replace with your application code */
	cli();
 2a4:	f8 94       	cli
	clk_init();
 2a6:	0e 94 75 00 	call	0xea	; 0xea <clk_init>
	interrupts_init();
 2aa:	0e 94 84 00 	call	0x108	; 0x108 <interrupts_init>
	timer_C4_init();
 2ae:	0e 94 88 00 	call	0x110	; 0x110 <timer_C4_init>
	timer_C5_init();
 2b2:	0e 94 94 00 	call	0x128	; 0x128 <timer_C5_init>
	timer_D5_init();
 2b6:	0e 94 a0 00 	call	0x140	; 0x140 <timer_D5_init>
	sei();
 2ba:	78 94       	sei
	
	PORTA.DIRSET = PIN3_bm;
 2bc:	88 e0       	ldi	r24, 0x08	; 8
 2be:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x7fb601>
	
	
	notesTreblePtr = nyanIntroTreble;
 2c2:	84 ef       	ldi	r24, 0xF4	; 244
 2c4:	90 e2       	ldi	r25, 0x20	; 32
 2c6:	80 93 1c 20 	sts	0x201C, r24	; 0x80201c <notesTreblePtr>
 2ca:	90 93 1d 20 	sts	0x201D, r25	; 0x80201d <notesTreblePtr+0x1>
	notesExtTreblePtr = nyanIntroExtTreble;
 2ce:	80 ec       	ldi	r24, 0xC0	; 192
 2d0:	91 e2       	ldi	r25, 0x21	; 33
 2d2:	80 93 1a 20 	sts	0x201A, r24	; 0x80201a <notesExtTreblePtr>
 2d6:	90 93 1b 20 	sts	0x201B, r25	; 0x80201b <notesExtTreblePtr+0x1>
	noteBeatCountTreble = 0;
 2da:	10 92 9f 21 	sts	0x219F, r1	; 0x80219f <noteBeatCountTreble>
	noteIndexTreble = 0;
 2de:	10 92 a3 21 	sts	0x21A3, r1	; 0x8021a3 <noteIndexTreble>
 2e2:	10 92 a4 21 	sts	0x21A4, r1	; 0x8021a4 <noteIndexTreble+0x1>
	noteExtIndexTreble = 0;
 2e6:	10 92 a1 21 	sts	0x21A1, r1	; 0x8021a1 <noteExtIndexTreble>
 2ea:	10 92 a2 21 	sts	0x21A2, r1	; 0x8021a2 <noteExtIndexTreble+0x1>
	noteExtBitPosTreble = 0;
 2ee:	10 92 a0 21 	sts	0x21A0, r1	; 0x8021a0 <noteExtBitPosTreble>
	
	notesBassPtr = nyanIntroBass;
 2f2:	8d e9       	ldi	r24, 0x9D	; 157
 2f4:	91 e2       	ldi	r25, 0x21	; 33
 2f6:	80 93 04 20 	sts	0x2004, r24	; 0x802004 <notesBassPtr>
 2fa:	90 93 05 20 	sts	0x2005, r25	; 0x802005 <notesBassPtr+0x1>
	notesExtBassPtr = nyanIntroExtBass;
 2fe:	89 e1       	ldi	r24, 0x19	; 25
 300:	90 e2       	ldi	r25, 0x20	; 32
 302:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <notesExtBassPtr>
 306:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <notesExtBassPtr+0x1>
	noteBeatCountBass = 0;
 30a:	10 92 94 21 	sts	0x2194, r1	; 0x802194 <__data_end>
	noteIndexBass = 0;
 30e:	10 92 98 21 	sts	0x2198, r1	; 0x802198 <noteIndexBass>
 312:	10 92 99 21 	sts	0x2199, r1	; 0x802199 <noteIndexBass+0x1>
	noteExtIndexBass = 0;
 316:	10 92 96 21 	sts	0x2196, r1	; 0x802196 <noteExtIndexBass>
 31a:	10 92 97 21 	sts	0x2197, r1	; 0x802197 <noteExtIndexBass+0x1>
	noteExtBitPosBass = 0;
 31e:	10 92 95 21 	sts	0x2195, r1	; 0x802195 <noteExtBitPosBass>
	
	setNoteAndBeatTreble();
 322:	0e 94 0c 01 	call	0x218	; 0x218 <setNoteAndBeatTreble>
	setNoteAndBeatBass();
 326:	0e 94 2f 01 	call	0x25e	; 0x25e <setNoteAndBeatBass>
	
	TCC4.CTRLA = TC_CLKSEL_DIV256_gc;
 32a:	86 e0       	ldi	r24, 0x06	; 6
 32c:	80 93 00 08 	sts	0x0800, r24	; 0x800800 <__TEXT_REGION_LENGTH__+0x7fb800>
 330:	ff cf       	rjmp	.-2      	; 0x330 <main+0x8c>

00000332 <__vector_12>:
		//TCD5.CCA = 0;
    }
}

ISR(TCC4_OVF_vect)
{
 332:	1f 92       	push	r1
 334:	0f 92       	push	r0
 336:	0f b6       	in	r0, 0x3f	; 63
 338:	0f 92       	push	r0
 33a:	11 24       	eor	r1, r1
 33c:	2f 93       	push	r18
 33e:	3f 93       	push	r19
 340:	4f 93       	push	r20
 342:	5f 93       	push	r21
 344:	6f 93       	push	r22
 346:	7f 93       	push	r23
 348:	8f 93       	push	r24
 34a:	9f 93       	push	r25
 34c:	af 93       	push	r26
 34e:	bf 93       	push	r27
 350:	ef 93       	push	r30
 352:	ff 93       	push	r31
	PORTA.OUTTGL = PIN3_bm;
 354:	88 e0       	ldi	r24, 0x08	; 8
 356:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <__TEXT_REGION_LENGTH__+0x7fb607>
	TCC4.INTFLAGS = TC4_OVFIF_bm;
 35a:	81 e0       	ldi	r24, 0x01	; 1
 35c:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <__TEXT_REGION_LENGTH__+0x7fb80c>

	if (!(noteBeatCountTreble))
 360:	80 91 9f 21 	lds	r24, 0x219F	; 0x80219f <noteBeatCountTreble>
 364:	81 11       	cpse	r24, r1
 366:	37 c0       	rjmp	.+110    	; 0x3d6 <__vector_12+0xa4>
	{	

	
		//First turn off treble counter
		TCC5.CTRLA = 0;
 368:	e0 e4       	ldi	r30, 0x40	; 64
 36a:	f8 e0       	ldi	r31, 0x08	; 8
 36c:	10 82       	st	Z, r1
		TCC5.CCA = 0;
 36e:	10 a6       	std	Z+40, r1	; 0x28
 370:	11 a6       	std	Z+41, r1	; 0x29

		if (noteIndexTreble >= trebleNoteCount)
 372:	20 91 a3 21 	lds	r18, 0x21A3	; 0x8021a3 <noteIndexTreble>
 376:	30 91 a4 21 	lds	r19, 0x21A4	; 0x8021a4 <noteIndexTreble+0x1>
 37a:	80 91 1e 20 	lds	r24, 0x201E	; 0x80201e <trebleNoteCount>
 37e:	90 91 1f 20 	lds	r25, 0x201F	; 0x80201f <trebleNoteCount+0x1>
 382:	28 17       	cp	r18, r24
 384:	39 07       	cpc	r19, r25
 386:	20 f1       	brcs	.+72     	; 0x3d0 <__vector_12+0x9e>
		{	
			if (isIntroTreble)
 388:	80 91 01 20 	lds	r24, 0x2001	; 0x802001 <isIntroTreble>
 38c:	88 23       	and	r24, r24
 38e:	a1 f0       	breq	.+40     	; 0x3b8 <__vector_12+0x86>
			{
				isIntroTreble = 0;
 390:	10 92 01 20 	sts	0x2001, r1	; 0x802001 <isIntroTreble>
				trebleNoteCount = MAIN_TREBLE_NOTE_COUNT;	
 394:	84 ed       	ldi	r24, 0xD4	; 212
 396:	90 e0       	ldi	r25, 0x00	; 0
 398:	80 93 1e 20 	sts	0x201E, r24	; 0x80201e <trebleNoteCount>
 39c:	90 93 1f 20 	sts	0x201F, r25	; 0x80201f <trebleNoteCount+0x1>
				notesTreblePtr = nyanMainTreble;
 3a0:	80 e2       	ldi	r24, 0x20	; 32
 3a2:	90 e2       	ldi	r25, 0x20	; 32
 3a4:	80 93 1c 20 	sts	0x201C, r24	; 0x80201c <notesTreblePtr>
 3a8:	90 93 1d 20 	sts	0x201D, r25	; 0x80201d <notesTreblePtr+0x1>
				notesExtTreblePtr = nyanMainExtTreble;			
 3ac:	85 ea       	ldi	r24, 0xA5	; 165
 3ae:	91 e2       	ldi	r25, 0x21	; 33
 3b0:	80 93 1a 20 	sts	0x201A, r24	; 0x80201a <notesExtTreblePtr>
 3b4:	90 93 1b 20 	sts	0x201B, r25	; 0x80201b <notesExtTreblePtr+0x1>
			}
			
			noteBeatCountTreble = 0;
 3b8:	10 92 9f 21 	sts	0x219F, r1	; 0x80219f <noteBeatCountTreble>
			noteIndexTreble = 0;
 3bc:	10 92 a3 21 	sts	0x21A3, r1	; 0x8021a3 <noteIndexTreble>
 3c0:	10 92 a4 21 	sts	0x21A4, r1	; 0x8021a4 <noteIndexTreble+0x1>
			noteExtIndexTreble = 0;
 3c4:	10 92 a1 21 	sts	0x21A1, r1	; 0x8021a1 <noteExtIndexTreble>
 3c8:	10 92 a2 21 	sts	0x21A2, r1	; 0x8021a2 <noteExtIndexTreble+0x1>
			noteExtBitPosTreble = 0;
 3cc:	10 92 a0 21 	sts	0x21A0, r1	; 0x8021a0 <noteExtBitPosTreble>
		}
		

		setNoteAndBeatTreble();	
 3d0:	0e 94 0c 01 	call	0x218	; 0x218 <setNoteAndBeatTreble>
 3d4:	03 c0       	rjmp	.+6      	; 0x3dc <__vector_12+0xaa>
			
	}
	else
	{
		noteBeatCountTreble--;
 3d6:	81 50       	subi	r24, 0x01	; 1
 3d8:	80 93 9f 21 	sts	0x219F, r24	; 0x80219f <noteBeatCountTreble>
	}
	
	if (!(noteBeatCountBass))
 3dc:	80 91 94 21 	lds	r24, 0x2194	; 0x802194 <__data_end>
 3e0:	81 11       	cpse	r24, r1
 3e2:	37 c0       	rjmp	.+110    	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
	{	
		//First turn off base counter
		
		TCD5.CTRLA = 0;
 3e4:	e0 e4       	ldi	r30, 0x40	; 64
 3e6:	f9 e0       	ldi	r31, 0x09	; 9
 3e8:	10 82       	st	Z, r1
		TCD5.CCA = 0;
 3ea:	10 a6       	std	Z+40, r1	; 0x28
 3ec:	11 a6       	std	Z+41, r1	; 0x29

		if (noteIndexBass >= bassNoteCount)
 3ee:	20 91 98 21 	lds	r18, 0x2198	; 0x802198 <noteIndexBass>
 3f2:	30 91 99 21 	lds	r19, 0x2199	; 0x802199 <noteIndexBass+0x1>
 3f6:	80 91 06 20 	lds	r24, 0x2006	; 0x802006 <bassNoteCount>
 3fa:	90 91 07 20 	lds	r25, 0x2007	; 0x802007 <bassNoteCount+0x1>
 3fe:	28 17       	cp	r18, r24
 400:	39 07       	cpc	r19, r25
 402:	20 f1       	brcs	.+72     	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
		{
			if (isIntroBass)
 404:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
 408:	88 23       	and	r24, r24
 40a:	a1 f0       	breq	.+40     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
			{
				isIntroBass = 0;
 40c:	10 92 00 20 	sts	0x2000, r1	; 0x802000 <__DATA_REGION_ORIGIN__>
				bassNoteCount = MAIN_BASS_NOTE_COUNT;
 410:	81 e1       	ldi	r24, 0x11	; 17
 412:	90 e0       	ldi	r25, 0x00	; 0
 414:	80 93 06 20 	sts	0x2006, r24	; 0x802006 <bassNoteCount>
 418:	90 93 07 20 	sts	0x2007, r25	; 0x802007 <bassNoteCount+0x1>
				notesBassPtr = nyanMainBass;
 41c:	88 e0       	ldi	r24, 0x08	; 8
 41e:	90 e2       	ldi	r25, 0x20	; 32
 420:	80 93 04 20 	sts	0x2004, r24	; 0x802004 <notesBassPtr>
 424:	90 93 05 20 	sts	0x2005, r25	; 0x802005 <notesBassPtr+0x1>
				notesExtBassPtr = nyanMainExtBass;
 428:	8a e9       	ldi	r24, 0x9A	; 154
 42a:	91 e2       	ldi	r25, 0x21	; 33
 42c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <notesExtBassPtr>
 430:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <notesExtBassPtr+0x1>
			}
			
			noteBeatCountBass = 0;
 434:	10 92 94 21 	sts	0x2194, r1	; 0x802194 <__data_end>
			noteIndexBass = 0;
 438:	10 92 98 21 	sts	0x2198, r1	; 0x802198 <noteIndexBass>
 43c:	10 92 99 21 	sts	0x2199, r1	; 0x802199 <noteIndexBass+0x1>
			noteExtIndexBass = 0;
 440:	10 92 96 21 	sts	0x2196, r1	; 0x802196 <noteExtIndexBass>
 444:	10 92 97 21 	sts	0x2197, r1	; 0x802197 <noteExtIndexBass+0x1>
			noteExtBitPosBass = 0;
 448:	10 92 95 21 	sts	0x2195, r1	; 0x802195 <noteExtBitPosBass>
		}

		setNoteAndBeatBass();		
 44c:	0e 94 2f 01 	call	0x25e	; 0x25e <setNoteAndBeatBass>
 450:	03 c0       	rjmp	.+6      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
	}
	else
	{
		noteBeatCountBass--;
 452:	81 50       	subi	r24, 0x01	; 1
 454:	80 93 94 21 	sts	0x2194, r24	; 0x802194 <__data_end>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 458:	2f ef       	ldi	r18, 0xFF	; 255
 45a:	83 ef       	ldi	r24, 0xF3	; 243
 45c:	91 e0       	ldi	r25, 0x01	; 1
 45e:	21 50       	subi	r18, 0x01	; 1
 460:	80 40       	sbci	r24, 0x00	; 0
 462:	90 40       	sbci	r25, 0x00	; 0
 464:	e1 f7       	brne	.-8      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
 466:	00 c0       	rjmp	.+0      	; 0x468 <__LOCK_REGION_LENGTH__+0x68>
 468:	00 00       	nop
	}	
	
	
		//TODO: Update display and start transfer
		_delay_ms(20);
	TCC5.CTRLA = TC_CLKSEL_DIV8_gc;
 46a:	84 e0       	ldi	r24, 0x04	; 4
 46c:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x7fb840>
	TCD5.CTRLA = TC_CLKSEL_DIV8_gc;		
 470:	80 93 40 09 	sts	0x0940, r24	; 0x800940 <__TEXT_REGION_LENGTH__+0x7fb940>
 474:	ff 91       	pop	r31
 476:	ef 91       	pop	r30
 478:	bf 91       	pop	r27
 47a:	af 91       	pop	r26
 47c:	9f 91       	pop	r25
 47e:	8f 91       	pop	r24
 480:	7f 91       	pop	r23
 482:	6f 91       	pop	r22
 484:	5f 91       	pop	r21
 486:	4f 91       	pop	r20
 488:	3f 91       	pop	r19
 48a:	2f 91       	pop	r18
 48c:	0f 90       	pop	r0
 48e:	0f be       	out	0x3f, r0	; 63
 490:	0f 90       	pop	r0
 492:	1f 90       	pop	r1
 494:	18 95       	reti

00000496 <_exit>:
 496:	f8 94       	cli

00000498 <__stop_program>:
 498:	ff cf       	rjmp	.-2      	; 0x498 <__stop_program>
